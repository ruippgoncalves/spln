# TPC1: Repetitive Line Remover Filter

This script is a command-line utility that removes duplicate lines from a text file (or standard input). It provides three modes:

1. Default Mode: Outputs unique lines, maintaining their order.
2. `--unique` Mode: Outputs the line numbers of unique (non-duplicate) lines.
3. `--duplicate` Mode: Outputs the line numbers of duplicate lines.

## Code

This notebook has been designed to allow the export of the entire code with the following shell script:

```shell
jupyter nbconvert --to python --TagRemovePreprocessor.remove_input_tags="test" rl.ipynb --output rl.py
chmod +x rl.py
mv rl.py /usr/bin/rl
```

This way, the test cells are removed. Furthermore, the `README.md` can be generated by running the following shell script:

```shell
jupyter nbconvert --to markdown --execute rl.ipynb --output README.md
```


```python
#!/usr/bin/env python3
import sys
import argparse
```

Let's start by writing the main code for processing the lines. It simply works by keeping track of the unique lines in the set. In this code we are using `yield` so that the return of the function is a stream iterator, allowing the stdin to work as expected.


```python
def process_lines(lines, mode='default'):
    line_set = set()

    for idx, line in enumerate(lines, start=1):
        if line in line_set:
            if mode == 'duplicate':
                yield str(idx)
        else:
            line_set.add(line)

            if mode == 'unique':
                yield str(idx)
            elif mode == 'default':
                yield line.rstrip('\n')
```


```python
sample = '''
Lorem ipsum odor amet, consectetuer adipiscing elit.
Accumsan at consectetur egestas scelerisque interdum lorem.
Libero class libero litora nam aliquet facilisis iaculis elementum dolor.
Malesuada laoreet tortor nam posuere eget sagittis varius. Molestie donec ad metus orci a.
Parturient class dolor molestie lacus dui ut feugiat.
Conubia curae elementum parturient faucibus accumsan.
Sed ante vestibulum platea himenaeos rhoncus sollicitudin mollis.

Lorem ipsum odor amet, consectetuer adipiscing elit.
Sed ante vestibulum platea himenaeos rhoncus sollicitudin mollis.
'''
sample_lines = sample.splitlines(keepends=True)

print('default:', list(process_lines(sample_lines, mode='default'))) # should output the text from lines [2,10[
print('unique:', list(process_lines(sample_lines, mode='unique'))) # should output [1, 2, 3, 4, 5, 6, 7, 8]
print('duplicate:', list(process_lines(sample_lines, mode='duplicate'))) # should output [9, 10, 11]
```

    default: ['', 'Lorem ipsum odor amet, consectetuer adipiscing elit.', 'Accumsan at consectetur egestas scelerisque interdum lorem.', 'Libero class libero litora nam aliquet facilisis iaculis elementum dolor.', 'Malesuada laoreet tortor nam posuere eget sagittis varius. Molestie donec ad metus orci a.', 'Parturient class dolor molestie lacus dui ut feugiat.', 'Conubia curae elementum parturient faucibus accumsan.', 'Sed ante vestibulum platea himenaeos rhoncus sollicitudin mollis.']
    unique: ['1', '2', '3', '4', '5', '6', '7', '8']
    duplicate: ['9', '10', '11']
    

Next, we must deal with the cli arguments, for that we are going to use the argparse python library. By default, it uses the `sys.stdin` and `sys.stdout` as the input and output, but that can be changed by providing the filename as an argument and using the `-o` and providing the output filename. Furthermore, the mutually exclusive `--unique` and `--duplicate` will toggle the used mode.


```python
def parse_args():
    parser = argparse.ArgumentParser(
        prog='rl.py',
        description='Removes repetitive lines',
    )
    parser.add_argument(
        'filename',
        nargs='?',
        default='',
        help='Input file (default: stdin)'
    )
    parser.add_argument(
        '-o', '--output',
        type=str,
        default='',
        help='Output file (default: stdout)'
    )
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument(
        '-u',
        '--unique',
        action='store_true',
        help='Print indexes of unique lines'
    )
    mode_group.add_argument(
        '-d',
        '--duplicate',
        action='store_true',
        help='Print indexes of duplicate lines'
    )
    args = parser.parse_args()

    # Setup
    lines = sys.stdin
    out_file = sys.stdout
    mode = 'default'

    if args.filename:
        try:
            lines = open(args.filename, 'r')
        except Exception as e:
            sys.exit(f'Error opening input file "{args.filename}": {e}')

    if args.output:
        try:
            out_file = open(args.output, 'w')
        except Exception as e:
            sys.exit(f'Error opening output file "{args.output}": {e}')

    if args.unique:
        mode = 'unique'
    elif args.duplicate:
        mode = 'duplicate'

    return lines, out_file, mode

def clean_files(lines, out_file):
    if lines is not sys.stdin:
        lines.close()
    if out_file is not sys.stdout:
        out_file.close()
```

Lastly, the last remaining part is the entrypoint itself.


```python
if __name__ == '__main__' and 'ipykernel' not in sys.modules:
    lines, out_file, mode = parse_args()

    for out in process_lines(lines, mode):
        print(out, file=out_file)

    clean_files(lines, out_file)
```
